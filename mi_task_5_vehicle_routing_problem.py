# -*- coding: utf-8 -*-
"""MI Task 5 Vehicle Routing Problem.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1MqLF-BAOPARHdDAHEX35Jxw3NNgwrHyz
"""

# Vehicle routing problem (VRP)
# It is a variant of a Travelling salesman problem (see https://en.wikipedia.org/wiki/Travelling_salesman_problem)
# Let us assume that you have the following constriction: 1 vehicle and 1 depo. The vehicle must start and end its journey at the depo. The task is to find the shortest and longest routes between cities, ensuring that every city is visited only once.
# Implement the algorithm in Python or Wolfram Mathematica
# Find the solutions using Brute force search (https://en.wikipedia.org/wiki/Brute-force_search)
# Your input must have the following (inputs sets by user):
# Number of cities
# Your output must have the following:
# Shortest path (image of the path, string/array representation of the shortest path, time to find the path)
# Longest path (image of the path, string/array representation of the longest path, time to find the path)

# importing required libraries
import itertools
import time
import matplotlib.pyplot as plt

import itertools
import time
import matplotlib.pyplot as plt

def calculate_total_distance(points):
    """
    Calculates the total distance between points in a given path.

    Parameters:
    points (tuple): A tuple of (x, y) coordinates of the points in the path.

    Returns:
    float: The total distance between the points.
    """
    total_distance = 0
    for i in range(len(points)-1):
        distance = ((points[i][0]-points[i+1][0])**2 + (points[i][1]-points[i+1][1])**2)**0.5
        total_distance += distance
    return total_distance

# Ask the user to enter the number of points
total_num_points = int(input("Enter the number of points: "))

# Ask the user to enter the coordinates of each point
points = []
for i in range(total_num_points):
    x, y = map(int, input(f"Enter the x and y coordinates of point {i+1}: ").split())
    points.append((x, y))

# Generate all possible arrangements of points
arrangements = list(itertools.permutations(points))

# Add the starting and ending point to each arrangement
for i in range(len(arrangements)):
    arrangements[i] = ((0, 0),) + arrangements[i] + ((0, 0),)

# Initialize variables to hold the shortest and longest distances and paths
shortest_distance = float('inf')
longest_distance = float('-inf')
shortest_path = None
longest_path = None

# Perform Brute Force search to find the shortest and longest paths
start_time = time.time()
for path in arrangements:
    distance = calculate_total_distance(path)
    if distance < shortest_distance:
        shortest_distance = distance
        shortest_path = path
    if distance > longest_distance:
        longest_distance = distance
        longest_path = path
end_time = time.time()

# Print the results
print(f"The shortest path is {shortest_path} with distance {shortest_distance}")
print(f"The longest path is {longest_path} with distance {longest_distance}")
print(f"Time taken to find the paths: {end_time - start_time} seconds")

# Plot the shortest path
x_values = [point[0] for point in shortest_path]
y_values = [point[1] for point in shortest_path]
plt.plot(x_values, y_values, '-o')
plt.title(f"Shortest path with distance {shortest_distance}")
plt.show()

# Plot the longest path
x_values = [point[0] for point in longest_path]
y_values = [point[1] for point in longest_path]
plt.plot(x_values, y_values, '-o')
plt.title(f"Longest path with distance {longest_distance}")
plt.show()

# Print the results again
print(f"The shortest path is {shortest_path} with distance {shortest_distance}")
print(f"The longest path is {longest_path} with distance {longest_distance}")
print(f"Time taken to find the paths: {end_time - start_time} seconds")

